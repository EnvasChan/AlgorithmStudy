#include "선택.h"

#ifdef acm2580

// Today problem : https://www.acmicpc.net/problem/2580


#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int board[10][10] = { 0 };

int dolphin(int node_value,int  )//함수 제목은 꼴리는데로 썼음
{

}




int main()
{
    for (int i = 0; i < 9; i++)
    {
        for (int j = 0; j < 9; j++)
        {
            cin >> board[j][i];
        }
    }






    return 0;
}

#endif


/*
int row;
row = 1 << 8 + 1 << 7 + ... + 1 << 2 + 1 << 0; 1

 1 1111 1111
11 1111 1110

row = 1 << 9 + 1 << 8 + ... + 1 << 2; --> 111 1111 1110
0 3 5 4 6 9 2 7 8 --> 2 3 4 5 6 7 8 9 --> [1]
7 8 2 1 0 5 6 0 9 --> 1 2 5 6 7 8 9 --> [3, 4]
0 6 0 2 7 8 1 3 5 
3 2 1 0 4 6 8 9 7
8 0 4 9 1 3 5 0 6
5 9 6 8 2 0 4 1 3
9 1 7 6 5 2 0 8 0
6 0 3 7 0 1 9 5 2
2 5 8 3 9 4 7 6 0



빈 칸 하나 고름,
후보 만들기,
후보에 대해서 DFS를 해봄

1, 3, 7
1을 넣고 풀어보고
3을 넣고 풀어보고
7을 넣고 풀어보면



x축의 같은 원소가 있는지 확인
y축의 같은 원소가 있는지 확인

9칸 검색해서 인접한 노드에 자신과 같은 값이 있는 노드가 있는지 확인

값이 0인 노드에 위 조건들의 충족하는 원소를 집어넣는다.

빈칸을 찾는법

45 - 지금까지 조건을 충족하는 모든 값들의 합 = 찾아야하는 값 

저장해야할 값 
있는지 확인한 노드값
지금 검사중인 노드의 위치



어른들 
문제 A -> 문제 1, 2, 3, 4, 5, 6
지금까지 있는 방법으로 어떻게 풀 지 대입 

어린이들
아주 디테일한 곳에서 창의적인 아이디어를 냄 --> 되는 경우가 거의 없음

*/